"""
schema.py contains all of the input and output schemas for our server

The schemas are all defined with marshmallow, which you can read about here
=> https://marshmallow.readthedocs.io/

ðŸš¨ Changing the keys on the schemas will change the inputs and outputs for our server.
ðŸš¨ So before you change the keys, please check that all of our clients are updated!

The schemas are tested by writing tests for the controllers. We could instead choose to
test the schemas directly, if they controller tests (and their database calls) become
too heavy.

TODO - pipe all of these into autogenerated OpenAPI v3 definitions.
"""

import database.models as models
from marshmallow import EXCLUDE, Schema, fields, pre_load
from marshmallow.validate import Range


class UserInputSchema(Schema):
    """
    UserInputSchema represents the schema that clients *input* into our server.
    So for example, it is the schema that you should respect when `POST`ing the server.

    Takes in input that looks like so:
    {
        "email": "lynncyrin@gmail.com",
        "role": "engineer",
        ...
    }
    """

    # required fields
    email = fields.Email(required=True)
    role = fields.Str(required=True)

    # optional fields
    familyName = fields.Str()
    givenName = fields.Str()
    smsUser = fields.Boolean(allow_none=True)

    @classmethod
    def update_user(cls, user: models.User, data: {}) -> models.User:
        """
        update_user takes in a user and schema data, and updates that user with the current schema data
        """
        # TODO - if would be nice if this was something like
        # `data.fields.email.value` instead! Need to check if the
        # marshmallow API supports that.
        user.email = data.get("email")
        user.role = data.get("role")
        user.familyName = data.get("familyName")
        user.givenName = data.get("givenName")
        user.smsUser = data.get("smsUser")
        return user

    class Meta:
        unknown = EXCLUDE


class UserOutputSchema(UserInputSchema):
    """
    UserOutputSchema represents the schema that clients recieve as *output* from our server.
    It has all of the values of the UserOutputSchema, with the addition of the autogenerated
    id field.

    When deserialized, it has output like so
    {
        "id": 1234, # <== this is the extra field this class adds
        "email": "lynncyrin@gmail.com",
        "role": "engineer",
        ...
    }
    """

    id = fields.Integer(validate=[Range(min=0, error="must not be negative")])

    @pre_load
    def preprocess(self, user: models.User, **kwargs) -> {}:
        """
        from_model takes in a user model, and creates the user output schema data
        """
        return {
            # TODO - if would be nice if this was something like
            # `self.fields.id.key` instead! Need to check if the
            # marshmallow API supports that.
            "id": user.id,
            "email": user.email,
            "role": user.role,
            "familyName": user.familyName,
            "givenName": user.givenName,
            "smsUser": user.smsUser,
        }

    class Meta:
        unknown = EXCLUDE


class UserPathSchema(Schema):
    """
    UserPathSchema represents the path parameter schema to use when making GET requests
    for our users endpoints.

    For example, given the request...
    GET /users/5000
               ^
               the schema defines the data input here
    """

    user_id = fields.Integer(
        required=True, validate=[Range(min=0, error="must not be negative")]
    )


class UserQuerySchema(Schema):
    """
    UserQuerySchema represents the query string schema to use when making GET requests
    for our users endpoints.

    For example, given the request...
    GET /users?page=20&limit=10
              ^
              the schema defines the data from this point, and on.
    """

    # WRT both `default` and `missing` being present here, see
    #  => https://github.com/marshmallow-code/marshmallow/issues/775
    page = fields.Integer(
        default=1, missing=1, validate=[Range(min=0, error="must not be negative")]
    )
    limit = fields.Integer(
        default=50,
        missing=50,
        # 1000 is my napkin math estimate for the a number that will prevent the server
        # overloading the database with massive GET requests
        validate=[
            Range(max=1000, error="limit must be less than 1000"),
            Range(min=0, error="must not be negative"),
        ],
    )

    roles = fields.List(fields.String)

    class Meta:
        unknown = EXCLUDE
